---
title: '소켓프로그래밍'
date: '2026-01-09'
description: '소켓프로그래밍 정리'
---
# 임시 문서입니다.

# 소켓 프로그래밍이란? 
- **소켓**은 **프로세스**간에 **데이터**를 **주고받기** 위해 사용되는, **OS**단에서 추상화된 **객체**입니다.
- 여기에서 말하는 **프로세스**는, **하나의 컴퓨터** 안에 존재하는 프로세스일 수도, **멀리 떨어진 컴퓨터들 간**의 프로세스일 수도 있습니다.(일반적으로 떨어진 컴퓨터간의 통신)
- 소켓 프로그래밍이란, 이 소켓을 사용하여 **데이터**를 **빠르고 안정적**으로 잘 **주고받는** 프로그램을 만드는 것입니다.

## 소켓 통신(Network I/O)
- 소켓 통신은 **입력과 출력**으로 취급할 수 있으며, 이는 일반적인 콘솔 IO / 파일 IO처럼 데이터(바이트) 입출력으로 볼 수 있습니다.
- **네트워크 환경**에 종속된다는 특징이 있습니다.(네트워크 품질에 따른 속도, 지연, 유실 문제 발생)
- 소켓통신은 Transport 계층 위에서 동작하며, TCP나 UDP와 같은 프로토콜을 통해 송수신된 데이터를 다루게 됩니다.(일반적으로 TCP 환경을 가정)

## 프로토콜 설계(메시지 경계 설정)
- TCP 환경 상에서, 상대방이 주어진 데이터가 순서대로, 손실 없이 도착하게 됩니다. 이는 연속적인 바이트 스트림으로 메시지가 송수신된다는 특징을 가집니다.
- 끊임없이 들어오는 바이트 스트림을 사용하기 위해서는 유의미한 단위로 구분지어 파싱하기 위해 자신만의 프로토콜을 구현해야 합니다. 
- 이를 위해 보통 고정 길이 기반 프로토콜을 사용하게 되며, 앞의 n 바이트 길이의 헤더를 읽고서 파싱 후 헤더에 있는 페이로드 길이 정보 m 바이트만큼을 파싱하는 방식으로 바이트 스트림을 처리합니다.
- 혹은, http 프로토콜처럼 \n\r와 같은 구분자 설정을 통해 프로토콜을 설계할 수 있지만, 이를 위해 연속적으로 파싱을 시도해 패턴 매칭을 해야한다는 점과 헤더 내용이 제한될 수 있다는 단점이 있습니다.

## 버퍼 설계
- 메모리 효율을 위해, 미리 할당받은 버퍼에 소켓으로부터 수신한 데이터를 쌓아두고서 해당 데이터를 파싱하는 식으로 소켓통신을 하게 됩니다. 
- 파싱을 하다보면 계속해서 버퍼 오프셋이 뒤로 밀리게 되고 그러다보면 남아있는 버퍼의 크기가 모자라게 됩니다. 
- 이 때, 새로 수신받은 데이터를 버퍼에 옮기기 전에 기존 버퍼에 남아있던 잔존 데이터들을 버퍼의 맨 앞 부분으로 이동해주고 뒤로 이어 수신하는 방식으로 메모리 절약을 해야 합니다.


# 비동기 프로그래밍
- 소켓통신과 같은 IO Bound 작업은 해당 작업이 언제 종료된지 모른다는 불확실성을 갖습니다.
- 이를 위해 제일 단순한 방법은 기본적인 콘솔 입출력처럼, 동기적인 함수를 호출한 뒤 입출력이 일어날 때까지 스레드를 block해버리는 방법이 있습니다.
- 이 방법의 가장 큰 문제점은 하나의 소켓에 대해 하나의 스레드가 block 돼버려 한 번에 수백 수천개의 소켓을 열어 처리하는 서버측의 경우 수천개의 스레드를 생성한 후 동기적으로 입출력을 받아야하는 방식으로 동작하게 된다는 것입니다.
- 비동기 입출력의 경우 OS에 송신/수신 요청을 보낸 뒤 나중에 해당 IO 작업이 끝났음을 알려주는 신호를 받은 뒤 처리를 합니다.
- 스레드 블로킹을 피할 수는 없습니다. 어딘가에서 OS의 시그널을 감지해서 작업을 해주는 스레드는 필요합니다. 요지는, 하나의 블로킹 스레드로써 여러개의 작업을 처리 한다는 것입니다. 

## Event Select
## Epoll(Linux)
## IO_uring(Linux)
## IOCP(Windows)
## RIO(Windows)

# Berkeley Software Distribution(BSD) 소켓
- 소켓 통신의 표준이 되는 버클리 소켓입니다. Windows에서나 Linux에서나 기본적으로 버클리 소켓 인터페이스를 따릅니다.